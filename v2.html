<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro ìë§‰ ìƒì„±ê¸° (No Server / No API)</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.min.js"></script>
    <style>
        :root { --primary: #4A90E2; --bg: #f8f9fa; }
        body { font-family: 'Pretendard', sans-serif; background: var(--bg); padding: 20px; display: flex; justify-content: center; }
        .container { background: white; width: 100%; max-width: 800px; padding: 30px; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        h1 { font-size: 1.5rem; color: #333; margin-bottom: 20px; text-align: center; }
        
        .upload-box { border: 2px dashed #ddd; padding: 40px; text-align: center; border-radius: 12px; transition: 0.3s; margin-bottom: 20px; }
        .upload-box:hover { border-color: var(--primary); background: #f0f7ff; }
        
        .status-area { margin: 20px 0; }
        .progress-container { height: 10px; background: #eee; border-radius: 5px; overflow: hidden; margin-bottom: 10px; display: none; }
        #progressBar { height: 100%; background: var(--primary); width: 0%; transition: width 0.3s; }
        #statusText { font-size: 0.9rem; color: #666; text-align: center; }

        .controls { display: flex; gap: 10px; margin-bottom: 20px; }
        select, button { padding: 12px; border-radius: 8px; border: 1px solid #ddd; font-size: 1rem; }
        button { flex: 1; background: var(--primary); color: white; border: none; font-weight: bold; cursor: pointer; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #downloadBtn { background: #28a745; }

        pre { background: #2d2d2d; color: #adbac7; padding: 15px; border-radius: 8px; height: 250px; overflow-y: auto; font-family: monospace; font-size: 0.85rem; }
    </style>
</head>
<body>

<div class="container">
    <h1>ğŸ™ï¸ AI ìë§‰ ìƒì„± ìŠ¤íŠœë””ì˜¤</h1>

    <div class="upload-box" id="dropZone">
        <input type="file" id="videoInput" accept="video/*" style="display: none;">
        <p id="fileName">ë™ì˜ìƒ íŒŒì¼ì„ ì„ íƒí•˜ê±°ë‚˜ ì´ë¦¬ë¡œ ëŒì–´ë‹¤ ë†“ìœ¼ì„¸ìš”.</p>
        <button onclick="document.getElementById('videoInput').click()">íŒŒì¼ ì°¾ê¸°</button>
    </div>

    <div class="controls">
        <select id="languageSelect">
            <option value="korean">í•œêµ­ì–´</option>
            <option value="english">ì˜ì–´</option>
            <option value="auto">ì–¸ì–´ ìë™ ê°ì§€</option>
        </select>
        <button id="startBtn">ìë§‰ ìƒì„± ì‹œì‘</button>
        <button id="downloadBtn" disabled>SRT ë‹¤ìš´ë¡œë“œ</button>
    </div>

    <div class="status-area">
        <div class="progress-container" id="progressContainer">
            <div id="progressBar"></div>
        </div>
        <div id="statusText">ì¤€ë¹„ ì™„ë£Œ</div>
    </div>

    <h3>ìë§‰ ë¯¸ë¦¬ë³´ê¸°</h3>
    <pre id="output">ì´ê³³ì— ì‹¤ì‹œê°„ ë¡œê·¸ì™€ ìë§‰ì´ í‘œì‹œë©ë‹ˆë‹¤.</pre>
</div>

<script type="module">
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile, toBlobURL } = FFmpegUtil;
    const ffmpeg = new FFmpeg();

    const startBtn = document.getElementById('startBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusText = document.getElementById('statusText');
    const progressBar = document.getElementById('progressBar');
    const progressContainer = document.getElementById('progressContainer');
    const output = document.getElementById('output');
    const videoInput = document.getElementById('videoInput');

    let finalSrt = "";

    // íŒŒì¼ ì„ íƒ ì´ë²¤íŠ¸
    videoInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) document.getElementById('fileName').innerText = file.name;
    };

    // ë¡œê·¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function log(msg) {
        const now = new Date().toLocaleTimeString();
        output.innerText += `\n[${now}] ${msg}`;
        output.scrollTop = output.scrollHeight;
    }

    startBtn.onclick = async () => {
        const file = videoInput.files[0];
        if (!file) return alert("ë™ì˜ìƒì„ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”.");

        try {
            startBtn.disabled = true;
            progressContainer.style.display = "block";
            output.innerText = "ê³„ì‚° ì‹œì‘...";

            // 1. FFmpeg ë¡œë“œ
            if (!ffmpeg.loaded) {
                statusText.innerText = "ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë”© ì¤‘...";
                await ffmpeg.load({
                    coreURL: await toBlobURL('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js', 'text/javascript'),
                    wasmURL: await toBlobURL('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm', 'application/wasm'),
                });
            }

            // 2. ì˜¤ë””ì˜¤ ì¶”ì¶œ
            log("ë™ì˜ìƒì—ì„œ ì˜¤ë””ì˜¤ ì¶”ì¶œ ì¤‘...");
            statusText.innerText = "ì˜¤ë””ì˜¤ ì¶”ì¶œ ì¤‘...";
            await ffmpeg.writeFile('input_file', await fetchFile(file));
            await ffmpeg.exec(['-i', 'input_file', '-ar', '16000', '-ac', '1', 'output.wav']);
            const audioData = await ffmpeg.readFile('output.wav');
            const audioBlob = new Blob([audioData.buffer], { type: 'audio/wav' });

            // 3. Whisper ìŒì„± ì¸ì‹ (Worker)
            log("AI ëª¨ë¸ ì‘ë™ ì‹œì‘...");
            runInference(audioBlob);

        } catch (e) {
            log("ì—ëŸ¬ ë°œìƒ: " + e.message);
            startBtn.disabled = false;
        }
    };

    function runInference(blob) {
        const lang = document.getElementById('languageSelect').value;
        
        const workerCode = `
            import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

            self.onmessage = async (e) => {
                const { blob, lang } = e.data;
                const url = URL.createObjectURL(blob);

                try {
                    const transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny', {
                        progress_callback: (p) => {
                            self.postMessage({ status: 'progress', progress: p });
                        }
                    });

                    const result = await transcriber(url, {
                        language: lang === 'auto' ? null : lang,
                        return_timestamps: true,
                        chunk_length_s: 30,
                        stride_length_s: 5
                    });

                    self.postMessage({ status: 'complete', result });
                } catch (err) {
                    self.postMessage({ status: 'error', error: err.message });
                }
            };
        `;

        const worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })), { type: 'module' });
        worker.postMessage({ blob, lang });

        worker.onmessage = (e) => {
            const { status, progress, result, error } = e.data;

            if (status === 'progress') {
                if (progress.status === 'downloading') {
                    statusText.innerText = `ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘: ${Math.round(progress.progress)}%`;
                    progressBar.style.width = `${progress.progress}%`;
                } else if (progress.status === 'done') {
                    log("ëª¨ë¸ ë¡œë“œ ì™„ë£Œ, ì—°ì‚° ì‹œì‘...");
                }
            } else if (status === 'complete') {
                finalSrt = formatSRT(result.chunks);
                output.innerText = finalSrt;
                statusText.innerText = "ìë§‰ ìƒì„± ì™„ë£Œ!";
                progressBar.style.width = "100%";
                downloadBtn.disabled = false;
                startBtn.disabled = false;
                log("ëª¨ë“  ì‘ì—…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.");
            } else if (status === 'error') {
                log("ì¸ì‹ ì˜¤ë¥˜: " + error);
                startBtn.disabled = false;
            }
        };
    }

    function formatSRT(chunks) {
        return chunks.map((c, i) => {
            const s = formatTime(c.timestamp[0]);
            const e = formatTime(c.timestamp[1] || c.timestamp[0] + 2);
            return \`\${i+1}\\n\${s} --> \${e}\\n\${c.text.trim()}\\n\\n\`;
        }).join('');
    }

    function formatTime(sec) {
        const hms = new Date(sec * 1000).toISOString().substr(11, 8);
        const ms = Math.floor((sec % 1) * 1000).toString().padStart(3, '0');
        return \`\${hms},\${ms}\`;
    }

    downloadBtn.onclick = () => {
        const blob = new Blob([finalSrt], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "subtitle.srt";
        a.click();
    };
</script>

</body>
</html>
