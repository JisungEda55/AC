<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì´ˆê°„í¸ ìë§‰ ìƒì„±ê¸° (Low-Quality OK)</title>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; background: #f4f4f4; color: #333; }
        .box { background: white; max-width: 600px; margin: auto; padding: 20px; border-radius: 10px; shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #log { background: #000; color: #0f0; padding: 10px; height: 200px; overflow-y: auto; font-family: monospace; font-size: 12px; border-radius: 5px; white-space: pre-wrap; }
        button { width: 100%; padding: 10px; margin: 10px 0; cursor: pointer; border: none; border-radius: 5px; background: #007bff; color: white; font-weight: bold; }
        button:disabled { background: #ccc; }
        progress { width: 100%; height: 20px; }
    </style>
</head>
<body>

<div class="box">
    <h2>ğŸ“Ÿ ì´ˆì €ì‚¬ì–‘ ìë§‰ê¸°</h2>
    <p>ì €í’ˆì§ˆ ëª¨ë¸(Tiny)ì„ ì‚¬ìš©í•˜ì—¬ ì†ë„ë¥¼ ë†’ì˜€ìŠµë‹ˆë‹¤.</p>
    
    <input type="file" id="fileInput" accept="video/*, audio/*">
    <button id="runBtn">ì‘ì—… ì‹œì‘ (ìë§‰ ë§Œë“¤ê¸°)</button>
    
    <div id="status">ìƒíƒœ: ëŒ€ê¸° ì¤‘</div>
    <progress id="pg" value="0" max="100"></progress>
    
    <div id="log">ë¡œê·¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...</div>
    
    <button id="downBtn" style="background:#28a745; display:none;">SRT íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
</div>

<script type="module">
    const { FFmpeg } = FFmpegWASM;
    const { fetchFile, toBlobURL } = FFmpegUtil;
    const ffmpeg = new FFmpeg();

    const logDiv = document.getElementById('log');
    const statusDiv = document.getElementById('status');
    const pg = document.getElementById('pg');
    const runBtn = document.getElementById('runBtn');
    const downBtn = document.getElementById('downBtn');

    let srtContent = "";

    // í™”ë©´ì— ë¡œê·¸ë¥¼ ì°ëŠ” í•¨ìˆ˜
    function addLog(msg) {
        logDiv.innerText += `\n> ${msg}`;
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    runBtn.onclick = async () => {
        const file = document.getElementById('fileInput').files[0];
        if (!file) return alert("íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”!");

        try {
            runBtn.disabled = true;
            addLog("í”„ë¡œê·¸ë¨ ì‹œì‘...");

            // 1. FFmpeg ë¡œë“œ
            if (!ffmpeg.loaded) {
                statusDiv.innerText = "ìƒíƒœ: ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œë“œ ì¤‘...";
                await ffmpeg.load({
                    coreURL: await toBlobURL('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.js', 'text/javascript'),
                    wasmURL: await toBlobURL('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd/ffmpeg-core.wasm', 'application/wasm'),
                });
            }

            // 2. ì˜¤ë””ì˜¤ ì¶”ì¶œ
            statusDiv.innerText = "ìƒíƒœ: ì˜¤ë””ì˜¤ ì¶”ì¶œ ì¤‘ (FFmpeg)";
            addLog("ì˜ìƒì—ì„œ ì†Œë¦¬ë§Œ ë½‘ì•„ë‚´ëŠ” ì¤‘...");
            await ffmpeg.writeFile('input', await fetchFile(file));
            await ffmpeg.exec(['-i', 'input', '-ar', '16000', '-ac', '1', 'audio.wav']);
            const data = await ffmpeg.readFile('audio.wav');
            const audioBlob = new Blob([data.buffer], { type: 'audio/wav' });

            // 3. AI ì¸ì‹ ì‹œì‘ (Worker í˜¸ì¶œ)
            statusDiv.innerText = "ìƒíƒœ: AI ë¶„ì„ ì¤‘ (Whisper Tiny)";
            addLog("AI ëª¨ë¸ ë¡œë”© ë° ë¶„ì„ ì‹œì‘ (ìµœì´ˆ 1íšŒ ë‹¤ìš´ë¡œë“œ)...");
            startAI(audioBlob);

        } catch (e) {
            addLog("ì—ëŸ¬ ë°œìƒ: " + e.message);
            runBtn.disabled = false;
        }
    };

    function startAI(blob) {
        // ì›Œì»¤ ì½”ë“œ
        const workerCode = `
            import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

            self.onmessage = async (e) => {
                try {
                    // ê°€ì¥ ê°€ë²¼ìš´ tiny ëª¨ë¸ ì‚¬ìš©
                    const transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny', {
                        progress_callback: (p) => { self.postMessage({ type: 'pg', p }); }
                    });

                    const url = URL.createObjectURL(e.data.blob);
                    const result = await transcriber(url, { 
                        language: 'korean', 
                        return_timestamps: true,
                        chunk_length_s: 30 
                    });

                    self.postMessage({ type: 'done', result });
                } catch (err) {
                    self.postMessage({ type: 'error', err: err.message });
                }
            };
        `;

        const worker = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })), { type: 'module' });
        worker.postMessage({ blob });

        worker.onmessage = (e) => {
            const res = e.data;
            if (res.type === 'pg') {
                if (res.p.status === 'downloading') {
                    pg.value = res.p.progress;
                    statusDiv.innerText = `ëª¨ë¸ ë‹¤ìš´ë¡œë“œ ì¤‘... (${Math.round(res.p.progress)}%)`;
                }
            } else if (res.type === 'done') {
                statusDiv.innerText = "ìƒíƒœ: ì‘ì—… ì™„ë£Œ!";
                addLog("ë¶„ì„ ì™„ë£Œ! ìë§‰ì„ ìƒì„±í•©ë‹ˆë‹¤.");
                
                srtContent = res.result.chunks.map((c, i) => {
                    const start = new Date(c.timestamp[0] * 1000).toISOString().substr(11, 12).replace('.', ',');
                    const end = new Date((c.timestamp[1] || c.timestamp[0]+2) * 1000).toISOString().substr(11, 12).replace('.', ',');
                    return `${i + 1}\n${start} --> ${end}\n${c.text.trim()}\n\n`;
                }).join('');

                addLog("ê²°ê³¼ë¬¼:\n" + srtContent.substring(0, 100) + "...");
                downBtn.style.display = "block";
                runBtn.disabled = false;
            } else if (res.type === 'error') {
                addLog("AI ì˜¤ë¥˜: " + res.err);
                runBtn.disabled = false;
            }
        };
    }

    downBtn.onclick = () => {
        const blob = new Blob([srtContent], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "subtitle.srt";
        a.click();
    };
</script>

</body>
</html>
